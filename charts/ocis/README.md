
[comment]: # (DONT EDIT THIS FILE, it is autogenerated. Instead you need to edit README.md.gotmpl)

# ownCloud Infinite Scale (oCIS) Helm chart
![Version: 0.0.0](https://img.shields.io/badge/Version-0.0.0-informational?style=flat-square) ![Type: application](https://img.shields.io/badge/Type-application-informational?style=flat-square) ![AppVersion: 2.0.0-beta.5](https://img.shields.io/badge/AppVersion-2.0.0--beta.5-informational?style=flat-square)

Installs [ownCloud Infinite Scale](http://owncloud.dev/ocis).

## Requirements

Currently we're supporting following Kubernetes versions (and their patch releases).
We are not testing the Helm chart on all versions, but ensure API compatibility by running manifest validation for the supported versions.

```
~1.20.0 || ~1.21.0 || ~1.22.0 || ~1.23.0 || ~1.24.0
```

## Helm chart Repository

This chart is still in an experimental phase, and it has not yet been published on a Helm chart repository.

## Installing the chart

To install the chart with the release name `my-release`:

* clone this git repository
* run `helm install my-release ./charts/ocis` from the root of this git repository

### minikube

1. Start your minikube cluster:

    ```console
    minikube start
    ```

1. Enable the minikube ingress plugin:

    ```console
    minikube addons enable ingress
    ```

1. Create a `values.yaml` with following contents:

    ```yaml
    externalDomain: ocis.kube.owncloud.test
    ingress:
      enabled: true
      annotations:
        nginx.ingress.kubernetes.io/proxy-body-size: 1024m
      tls:
      - hosts:
        - ocis.kube.owncloud.test
    insecure:
      # disables ssl certificate checking for connections to the openID connect identity provider. Not recommended for production setups, but we don't have valid certificates in minikube
      oidcIdpInsecure: true
      # disables ssl certificate checking for connections to the oCIS http apis. Not recommended for production setups, but we don't have valid certificates in minikube
      ocisHttpApiInsecure: true
    ```

1. Create all secrets as described in the [Secrets](#secrets) section

1. Install the with the values file applied

    ```console
    helm install ocis ./charts/ocis --values values.yaml
    ```

1. Get the minikube IP address

    ```console
    minikube ip
    ```

1. add the minikube IP address to your `/etc/hosts` file or use the [Ingress DNS addon](https://minikube.sigs.k8s.io/docs/handbook/addons/ingress-dns/).
  An example line for the `/etc/hosts` file could look like this:

    ```bash
    192.168.49.2 ocis.kube.owncloud.test
    ```

1. use oCIS in your browser on https://ocis.kube.owncloud.test.

## Uninstalling the chart

To uninstall/delete the my-release deployment:

```console
helm delete my-release
```

The command removes all the Kubernetes components associated with the chart and deletes the release.

## Upgrading an existing Release to a new major version

A major chart version change (like v1.2.3 -> v2.0.0) indicates that there is an
incompatible breaking change needing manual actions.

### Supported oCIS versions

This chart only supports following oCIS versions:

* 2.0.0-beta.4

## Configuration

| Key | Type | Default | Description |
|-----|------|---------|-------------|
| autoscaling.enabled | bool | `false` | Enables autoscaling. When set to `true`, `replicas` is no longer applied. |
| autoscaling.maxReplicas | int | `10` | Sets maximum replicas for autoscaling. |
| autoscaling.metrics | list | `[]` | Metrics to use for autoscaling |
| autoscaling.minReplicas | int | `3` | Sets minimum replicas for autoscaling. |
| deploymentStrategy | object | `{"type":"RollingUpdate"}` | Deployment strategy. |
| externalDomain | string | `"ocis.owncloud.test"` | Domain where oCIS is reachable for the outside world |
| extraLabels | object | `{}` | Custom labels for all manifests |
| extraResources | list | `[]` | Extra resources to be included. |
| features.basicAuthentication | bool | `false` | Enable basic authentication. Not recommended for production installations. |
| features.demoUsers | bool | `false` | Create demo users on the first startup. Not recommended for production installations. |
| image.pullPolicy | string | `"IfNotPresent"` | Image pull policy |
| image.repository | string | `"owncloud/ocis"` | Image repository |
| image.sha | string | `""` | Image sha / digest (optional). |
| image.tag | string | `"2.0.0-beta.5"` | Image tag. |
| ingress.annotations | object | `{}` | Ingress annotations. |
| ingress.enabled | bool | `false` | Enables the Ingress. |
| ingress.ingressClassName | string | `nil` | Ingress class to use. Uses the default ingress class if not set. |
| ingress.labels | object | `{}` | Labels for the ingress. |
| ingress.tls | list | `[]` | Ingress TLS configuration. |
| insecure.ocisHttpApiInsecure | bool | `false` | Disables SSL certificate checking for connections to the oCIS http apis. Not recommended for production installations. |
| insecure.oidcIdpInsecure | bool | `false` | Disables SSL certificate checking for connections to the openID connect identity provider. Not recommended for production installations. |
| logging.color | string | `"false"` | Activates colorized log output. Not recommended for production installations. |
| logging.level | string | `"error"` | Log level. Valid values: `panic`, `fatal`, `error`, `warn`, `info`, `debug`, `trace`. |
| logging.pretty | string | `"false"` | Activates pretty log output. Not recommended for production installations. |
| namespaceOverride | string | `nil` | Override the deployment namespace of all resources in this Helm chart. |
| replicas | int | `1` | Number of replicas for each scalable service. Has no effect when `autoscaling.enabled` is set to `true`. |
| resources | object | `{}` | Resources to apply to all services. |
| secretRefs.adminUserSecretRef | string | `"admin-user"` | Reference to an existing admin user secret (see [Secrets](#secrets)) |
| secretRefs.idpSecretRef | string | `"idp-secrets"` | Reference to an existing IDP secret (see [Secrets](#secrets)) |
| secretRefs.jwtSecretRef | string | `"jwt-secret"` | Reference to an existing JWT secret (see [Secrets](#secrets)) |
| secretRefs.ldapCaRef | string | `"ldap-ca"` | Reference to an existing LDAP certificate authority secret (see [Secrets](#secrets)) |
| secretRefs.ldapCertRef | string | `"ldap-cert"` | Reference to an existing LDAP cert secret (see [Secrets](#secrets)) |
| secretRefs.ldapSecretRef | string | `"ldap-bind-secrets"` | Reference to an existing LDAP bind secret (see [Secrets](#secrets)) |
| secretRefs.machineAuthApiKeySecretRef | string | `"machine-auth-api-key"` | Reference to an existing machine auth api key secret (see [Secrets](#secrets)) |
| secretRefs.storageSystemJwtSecretRef | string | `"storage-system-jwt-secret"` | Reference to an existing storage-system JWT secret (see [Secrets](#secrets)) |
| secretRefs.storageSystemSecretRef | string | `"storage-system"` | Reference to an existing storage-system secret (see [Secrets](#secrets)) |
| secretRefs.thumbnailsSecretRef | string | `"thumbnails-transfer-secret"` | Reference to an existing thumbnails transfer secret (see [Secrets](#secrets)) |
| secretRefs.transferSecretSecretRef | string | `"transfer-secret"` | Reference to an existing transfer secret (see [Secrets](#secrets)) |
| securityContext.fsGroup | int | `1000` | File system group for all volumes. |
| securityContext.runAsGroup | int | `1000` | Group ID that all processes within any containers will run with. |
| securityContext.runAsUser | int | `1000` | User ID that all processes within any containers will run with. |
| services.idm.persistence.accessModes | list | `["ReadWriteMany"]` | Persistent volume access modes. Needs to be `["ReadWriteMany"]` when scaling this service beyond one instance. |
| services.idm.persistence.annotations | object | `{}` | Persistent volume annotations. |
| services.idm.persistence.enabled | bool | `false` | Enables persistence. Needs to be enabled on production installations. If not enabled, pod restarts will lead to data loss. Also scaling this service beyond one instance is not possible if the service instances don't share the same storage. |
| services.idm.persistence.existingClaim | string | `nil` | Use an existing PersistentVolumeClaim for persistence. |
| services.idm.persistence.finalizers | list | `["kubernetes.io/pvc-protection"]` | Persistent volume finalizers. |
| services.idm.persistence.selectorLabels | object | `{}` | Persistent volume selector labels. |
| services.idm.persistence.size | string | `"10Gi"` | Size of the persistent volume. |
| services.idm.persistence.storageClassName | string | `nil` | Storage class to use. Uses the default storage class if not set. |
| services.nats.persistence.accessModes | list | `["ReadWriteMany"]` | Persistent volume access modes. Needs to be `["ReadWriteMany"]` when scaling this service beyond one instance. |
| services.nats.persistence.annotations | object | `{}` | Persistent volume annotations. |
| services.nats.persistence.enabled | bool | `false` | Enables persistence. Needs to be enabled on production installations. If not enabled, pod restarts will lead to data loss. Also scaling this service beyond one instance is not possible if the service instances don't share the same storage. |
| services.nats.persistence.existingClaim | string | `nil` | Use an existing PersistentVolumeClaim for persistence. |
| services.nats.persistence.finalizers | list | `["kubernetes.io/pvc-protection"]` | Persistent volume finalizers. |
| services.nats.persistence.selectorLabels | object | `{}` | Persistent volume selector labels. |
| services.nats.persistence.size | string | `"10Gi"` | Size of the persistent volume. |
| services.nats.persistence.storageClassName | string | `nil` | Storage class to use. Uses the default storage class if not set. |
| services.search.persistence.accessModes | list | `["ReadWriteMany"]` | Persistent volume access modes. Needs to be `["ReadWriteMany"]` when scaling this service beyond one instance. |
| services.search.persistence.annotations | object | `{}` | Persistent volume annotations. |
| services.search.persistence.enabled | bool | `false` | Enables persistence. Needs to be enabled on production installations. If not enabled, pod restarts will lead to data loss. Also scaling this service beyond one instance is not possible if the service instances don't share the same storage. |
| services.search.persistence.existingClaim | string | `nil` | Use an existing PersistentVolumeClaim for persistence. |
| services.search.persistence.finalizers | list | `["kubernetes.io/pvc-protection"]` | Persistent volume finalizers. |
| services.search.persistence.selectorLabels | object | `{}` | Persistent volume selector labels. |
| services.search.persistence.size | string | `"10Gi"` | Size of the persistent volume. |
| services.search.persistence.storageClassName | string | `nil` | Storage class to use. Uses the default storage class if not set. |
| services.storageSystem.persistence.accessModes | list | `["ReadWriteMany"]` | Persistent volume access modes. Needs to be `["ReadWriteMany"]` when scaling this service beyond one instance. |
| services.storageSystem.persistence.annotations | object | `{}` | Persistent volume annotations. |
| services.storageSystem.persistence.enabled | bool | `false` | Enables persistence. Needs to be enabled on production installations. If not enabled, pod restarts will lead to data loss. Also scaling this service beyond one instance is not possible if the service instances don't share the same storage. |
| services.storageSystem.persistence.finalizers | list | `["kubernetes.io/pvc-protection"]` | Persistent volume finalizers. |
| services.storageSystem.persistence.selectorLabels | object | `{}` | Persistent volume selector labels. |
| services.storageSystem.persistence.size | string | `"5Gi"` | Size of the persistent volume. |
| services.storageSystem.persistence.storageClassName | string | `nil` | Storage class to use. Uses the default storage class if not set. |
| services.storageUsers.persistence.accessModes | list | `["ReadWriteMany"]` | Persistent volume access modes. Needs to be `["ReadWriteMany"]` when scaling this service beyond one instance. |
| services.storageUsers.persistence.annotations | object | `{}` | Persistent volume annotations. |
| services.storageUsers.persistence.enabled | bool | `false` | Enables persistence. Needs to be enabled on production installations. If not enabled, pod restarts will lead to data loss. Also scaling this service beyond one instance is not possible if the service instances don't share the same storage. |
| services.storageUsers.persistence.existingClaim | string | `nil` | Use an existing PersistentVolumeClaim for persistence. |
| services.storageUsers.persistence.finalizers | list | `["kubernetes.io/pvc-protection"]` | Persistent volume finalizers. |
| services.storageUsers.persistence.selectorLabels | object | `{}` | Persistent volume selector labels. |
| services.storageUsers.persistence.size | string | `"50Gi"` | Size of the persistent volume. |
| services.storageUsers.persistence.storageClassName | string | `nil` | Storage class to use. Uses the default storage class if not set. |
| services.storageUsers.storageBackend.driver | string | `"ocis"` |  |
| services.store.persistence.accessModes | list | `["ReadWriteMany"]` | Persistent volume access modes. Needs to be `["ReadWriteMany"]` when scaling this service beyond one instance. |
| services.store.persistence.annotations | object | `{}` | Persistent volume annotations. |
| services.store.persistence.enabled | bool | `false` | Enables persistence. Needs to be enabled on production installations. If not enabled, pod restarts will lead to data loss. Also scaling this service beyond one instance is not possible if the service instances don't share the same storage. |
| services.store.persistence.existingClaim | string | `nil` | Use an existing PersistentVolumeClaim for persistence. |
| services.store.persistence.finalizers | list | `["kubernetes.io/pvc-protection"]` | Persistent volume finalizers. |
| services.store.persistence.selectorLabels | object | `{}` | Persistent volume selector labels. |
| services.store.persistence.size | string | `"5Gi"` | Size of the persistent volume. |
| services.store.persistence.storageClassName | string | `nil` | Storage class to use. Uses the default storage class if not set. |
| services.thumbnails.persistence.accessModes | list | `["ReadWriteMany"]` | Persistent volume access modes. Needs to be `["ReadWriteMany"]` when scaling this service beyond one instance or persistence needs to be disabled. |
| services.thumbnails.persistence.annotations | object | `{}` | Persistent volume annotations. |
| services.thumbnails.persistence.enabled | bool | `false` | Enables persistence. Is recommended to be enabled on production installations. If enabled, generated thumbnails are cached on this volume and available across pod restarts and service instances. If not enabled, thumbnail generation might lead to higher CPU usage. |
| services.thumbnails.persistence.existingClaim | string | `nil` | Use an existing PersistentVolumeClaim for persistence. |
| services.thumbnails.persistence.finalizers | list | `[]` | Persistent volume finalizers. |
| services.thumbnails.persistence.selectorLabels | object | `{}` | Persistent volume selector labels. |
| services.thumbnails.persistence.size | string | `"10Gi"` | Size of the persistent volume. |
| services.thumbnails.persistence.storageClassName | string | `nil` | Storage class to use. Uses the default storage class if not set. |

### Secrets

oCIS needs some secrets to work.
We decided against creating them automagically for you, because Helm does not support one-off generation of secrets out of the box.
Also oCIS needs to have some certificates, which should have an expiry and therefore need a certificate rotation from time to time.
This is also not supported by Helm.

These reasons add up and as a result the responsibility fore these secrets (and there lifecycle) lies at the operator, you.

We'll give you all information, you need to generate and maintain these secrets.

Following example shows you how the secrets need to look like and how you can generate them.
The example assumes, that you don't change the `secretRefs`.
Each secret data entry holds a description on how to generate it or find the right value.

You can apply the secrets manually or include them in the `extraResources`.

```yaml
---
apiVersion: v1
kind: Secret
metadata:
  name: jwt-secret
type: Opaque
data:
  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  jwt-secret: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: ldap-bind-secrets
type: Opaque
data:
  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  reva-ldap-bind-password: XXXXXXXXXXXXX

  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  idp-ldap-bind-password: XXXXXXXXXXXXX

  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  graph-ldap-bind-password: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: ldap-ca
type: Opaque
data:
  # how to generate: base64 encode the pem-encoded certificate of a (self-signed) x509 certificate authority
  # example generation commands:
  #  - `openssl genrsa -out ldap-ca.key 4096`
  #  - `openssl req -new -x509 -days 3650 -key ldap-ca.key -out ldap-ca.crt`
  #  - `cat ldap-ca.crt | base64 | tr -d '\n' && echo`
  ldap-ca.crt: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: ldap-cert
type: Opaque
data:
  # how to generate: base64 encode a private key (eg. ed25519, ensure that you use reasonable long key size)
  # example generation commands:
  #  - `openssl genrsa -out ldap.key 4096`
  #  - `cat ldap.key | base64 | tr -d '\n' && echo`
  ldap.key: XXXXXXXXXXXXX

  # how to generate: base64 encode a x509 certificate signed by the above CA, using the above private key.
  # example generation commands:
  #  - `openssl req -new -subj "/CN=idm" -key ldap.key -out ldap.csr`
  #  - `openssl x509 -req -extensions SAN -extfile <(cat /etc/ssl/openssl.cnf <(printf "\n[SAN]\nsubjectAltName=DNS:idm")) -days 365 -in ldap.csr -CA ldap-ca.crt -CAkey ldap-ca.key -out ldap.crt -CAcreateserial`
  #  - `cat ldap.crt | base64 | tr -d '\n' && echo`
  ldap.crt: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: machine-auth-api-key
type: Opaque
data:
  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  machine-auth-api-key: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: storage-system
type: Opaque
data:
  # how to generate: base64 encode a UUID V4
  # example generation command: `cat /proc/sys/kernel/random/uuid | tr -d '\n' | base64`
  user-id: XXXXXXXXXXXXX

  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  api-key: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: storage-system-jwt-secret
type: Opaque
data:
  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  storage-system-jwt-secret: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: transfer-secret
type: Opaque
data:
  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  transfer-secret: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: admin-user
type: Opaque
data:
  # how to generate: base64 encode a UUID V4
  # example generation command: `cat /proc/sys/kernel/random/uuid | tr -d '\n' | base64`
  user-id: XXXXXXXXXXXXX

  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[a-zA-Z0-9],.' < /dev/urandom | fold -w 50 | head -n 1 | tr -d '\n' | base64`
  password: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: idp-secrets
type: Opaque
data:
  # how to generate: base64 encode a random 32 byte string (mixed characters)
  # example generation command: `openssl rand 32 | base64`
  encryption.key: XXXXXXXXXXXXX

  # how to generate: base64 encode a private key (eg. RSA, ensure that you use reasonable long key size)
  # example generation command: `openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 2> /dev/null | base64 | tr -d '\n'`
  private-key.pem: XXXXXXXXXXXXX

---
apiVersion: v1
kind: Secret
metadata:
  name: thumbnails-transfer-secret
type: Opaque
data:
  # how to generate: base64 encode a random string (reasonable long and mixed characters)
  # example generation command: `tr -cd '[:alnum:],.' < /dev/urandom | fold -w 50 | head -n 1 | base64`
  thumbnails-transfer-secret: XXXXXXXXXXXXX
```

### Example with NGINX ingress and certificate issued by cert-manager

To make this work you need to have NGINX ingress and cert-manager installed in your cluster.

```yaml
  externalDomain: ocis.owncloud.test

  ingress:
    enabled: true
    ingressClassName: nginx
    annotations:
      cert-manager.io/issuer: "ocis-certificate-issuer"
    tls:
      - hosts:
        - ocis.owncloud.test
        secretName: ocis-tls-certificate

  extraResources:
    - |
      apiVersion: cert-manager.io/v1
      kind: Issuer
      metadata:
        name: ocis-certificate-issuer
        namespace: ocis-namespace
      spec:
        acme:
          server: https://acme-v02.api.letsencrypt.org/directory
          email: test@example.test
          privateKeySecretRef:
            name: ocis-certificate-issuer
          solvers:
          - http01:
              ingress:
                class: nginx
```
